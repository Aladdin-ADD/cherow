import { pass, fail } from '../../test-utils';
import { Context } from '../../../src/utilities';
import * as t from 'assert';
import { parse } from '../../../src/parser/parser';

describe('Miscellaneous - Early errors', () => {

    describe('Failure - sloppy / strict', () => {

        const invalidSyntax = [
            `'use strict'; delete ((a));`,
            `'use strict'; if (1) function a(){} else;`,
            `function* a(){ function* b(c = yield d){} }`,
            `!{ set a(eval){ 'use strict'; } };`,
            `(([]) => {"use strict";})`,
            `function a([]){"use strict";}`,
            `function* a(){ function* b(c = d + b(yield)){} }`,
            `function* g(){ function* f([a = yield]){} }`,
            `function* g(){ function* f(a = yield){} }`,
            `class A extends B { constructor() { function f(){ super(); } } }`,
            `function f(a = super()){}`,
            `var i\\u006E;`,
            `function* g(){ (a = yield* b) => 0; }`,
            `function* g(){ ({a = yield}) => 0; }`,
            `for(a in b) d: function c(){}`,
            `class A extends B { a() { function f(){ super.b(); } } }`,
            `[...new a] = 0;`,
            '({ a = 0 });',
            '(...a)',
            '(a, ...b)',
            '(((...a)))',
            '(((a, ...b)))',
            '0++',
            '0--',
            '++0',
            '--0',
            '({a: 0} = 0);',
            '({get a(){}} = 0)',
            '({set a(b){}} = 0)',
            '({a(b){}} = 0)',
            '[0] = 0;',
            '0 = 0;',
            '({a}) = 0;',
            '([a]) = 0;',
            '({a} += 0);',
            '[a] *= 0;',
            '0 /= 0;',
            '[...{a: 0}] = 0;',
            '[...[0]] = 0;',
            '[...0] = 0;',
            '[...new a] = 0;',
            'for({a: 0} in 0);',
            'for([0] in 0);',
            'for({a: 0} of 0);',
            'for([0] of 0);',
            'for(0 in 0);',
            'for(0 of 0);',
            'for(({a: 0}) in 0);',
            'for(([0]) in 0);',
            'for(({a: 0}) of 0);',
            'for(([0]) of 0);',
            'for((0) in 0);',
            'for((0) of 0);',
            '"use strict"; arguments = 0',
            //'"use strict"; [eval] = 0',
            //'"use strict"; [,,,eval,] = 0',
            '"use strict"; ({a: eval = 0} = 0)',
            // '"use strict"; [arguments] = 0',
            // '"use strict"; [,,,arguments,] = 0',
            // '"use strict"; ({a: arguments} = 0)',
            '"use strict"; ({a: arguments = 0} = 0)',
            '"use strict"; var eval;',
            '"use strict"; let [eval] = 0;',
            '"use strict"; const {a: eval} = 0;',
            '"use strict"; function f(eval){}',
            '"use strict"; !function f(eval){}',
            'function f(eval) { "use strict";}',
            'function *f(eval) { "use strict";}',
            '!function *f(eval) { "use strict";}',
            'class A { f(eval){} };',
            'class A { *f(eval){} };',
            'class A { set f(eval){} };',
            'class A extends (eval = null) { };',
            '!class extends (eval = null) { };',
            '"use strict"; +yield;',
            '"use strict"; yield:;',
            '"use strict"; +implements;',
            '"use strict"; +interface;',
            '"use strict"; +let;',
            '"use strict"; +package;',
            '"use strict"; +private;',
            '"use strict"; +protected;',
            '"use strict"; +public;',
            '"use strict"; +yield;',
            '"use strict"; +implements:0;',
            '"use strict"; +interface:0;',
            '"use strict"; +let:0;',
            '"use strict"; +package:0;',
            '"use strict"; +private:0;',
            '"use strict"; +protected:0;',
            '"use strict"; +static:0;',
            '"use strict"; function a([yield]){}',
            '"use strict"; function a({yield}){}',
            '"use strict";  function a({yield=0}){}',
            '"use strict"; function a({a:yield}){}',
            '"use strict"; function a([yield,...a]){}',
            '"use strict"; class A {set a(yield){}}',
            '({a(yield){ "use strict"; }});',
            //'!{ get a() { "use strict"; }};',
            '!{ set a(let) { "use strict"; }};',
            '"use strict"; delete (a);',
            '"use strict"; delete ((a));',
            '"use strict"; delete a;',
            // '"use strict"; ({eval} = 0);',
          // '"use strict"; ({arguments} = 0);',
            'for(let let;;);',
            'let a, let = 0;',
            'let a, let;',
            'for(let a, let;;);',
            'for(const let = 0;;);',
            'for(const a = 0, let = 1;;);',
            'for(let [let] = 0;;);',
            'const a;',
            'const a, b = 0;\'',
            'const a = 0, b;',
            '{ const a; }',
            'function f(){ const a; }',
            'for(const a;;);',
            'for(const a = 0, b;;);',
            'if(0) label: function f(){}',
            'if(0) labelA: labelB: function f(){}',
            'if(0) label: function f(){} else ;',
            'if(0) ; else label: function f(){}',
            'do label: function f(){} while (0)',
            'do label: function f(){} while (0);',
            'while(0) label: function f(){}',
            'for(;;) label: function f(){}',
            'for(var a;;) label: function f(){}',
            'for(const a = 0;;) label: function f(){}',
            'for(let a;;) label: function f(){}',
            'for(a in b) label: function f(){}',
            'for(var a in b) label: function f(){}',
            'for(let a in b) label: function f(){}',
            'for(const a in b) label: function f(){}',
            'for(a of b) label: function f(){}',
            'for(var a of b) label: function f(){}',
            'for(let a of b) label: function f(){}',
            'for(const a of b) label: function f(){}',
            'for(;;) labelA: labelB: labelC: function f(){}',
            'for(let let in 0);',
            'for(const let in 0);',
            'for(let let of 0);',
            'for(const let of 0);',
            '{ continue; }',
            'continue',
            'if(0) continue;',
            'while(0) !function(){ continue; };',
            'while(0) { function f(){ continue; } }',
            'label: continue label;',
            'label: { continue label; }',
            'label: if(0) continue label;',
            'label: while(0) !function(){ continue label; };',
            'label: while(0) { function f(){ continue label; } }',
            'break;',
            '{ break; }',
            'if(0) break;',
            'while(0) !function(){ break; };',
            'while(0) { function f(){ break; } }',
            'switch(0) { case 0: !function(){ break; }; }',
            'switch(0) { case 0: function f(){ break; } }',
            'switch(0) { default: function f(){ break; } }',
            'with(0) label: function f(){}',
             'function* g(){ (a = yield) => 0; }',
             'function* g(){ function* f(a = x + f(yield)){} }',
             'function* g(){ function* f({[yield]: a}){} }',
             'function* g(){ function* f({a = yield}){} }',
            'function* g(){ !function*(a = yield){} }',
            'function* g(){ !function*(a = yield b){} }',
            'function* g(){ !function*([a = yield]){} }',
            'function* g(){ !function*(...{a = yield}){} }',
             'function* a(){ function* b({[yield]: c}){} }',
            '({set a(b){}} = 0)',
            'package => {\'use strict\'}',
            '"use strict"; var yield;',
            '\'use strict\'; +protected;',
            'function* a(){ (b = yield c) => 1; }',
            'function a(){ c: while(1) continue b; }',
            'a: while (true) { (function () { break; }); }',
            'for(const a;;);',
            '!{ a(let) { \'use strict\'; } }',
            ' const a;',
            ' function a(eval) {\'use strict\';}',
            '" function a() { "use strict"; var interface; }',
            'function a() { "use strict"; private = 1; }',
            'class a { *constructor() {} }',
            ' function a() {\'use strict\'; arguments--; }',
            'b: while(1) { function a(){ continue b; } }',
            'do b: function a(){} while (1);',
            //"'use strict'; ({eval = 1} = 2);",
            'function a() { "use strict"; var implements; }',
            'function a([yield,...a]){ \'use strict\'; }',
             'function* a(){ function* b({c = yield}){} }',
            'while(1) b: function a(){}',
            'function a(){ \'use strict\'; function a(yield){}}',
            // " 'use strict'; [eval] = 1",
            'for(const a in b) d: function c(){}',
            'function a() { \'use strict\'; let = 1; }',
            ' for(0 of 0);',
            ' [...new a] = 0;',
            ' for(const a = 1, let = 2;;);',
            ` function a() { "use strict"; private = 1; }`,
            `for((0) in 0);`,
            ` for(const a in b) d: function c(){}`,
            ` /./ii`,
            `(a, ...b)`,
            `(((a, ...b)))`,
            `[...{a: 0}] = 0;`,
            `for({a: 0} of 0);`,
            `for((0) in 0);`,
            `do label: function f(){} while (0)`,
            `label: continue label;`,
            `label: while(0) !function(){ continue label; };`,
            'function a() { "use strict"; function b(arguments) {} }',
            '"use strict"; arguments *= 1',
            'function a() { "use strict"; interface = 1; }',
            'for(const a;;);',
            `"use strict"; for (a in let) {}`,
            'class a { *b(eval){} };',
            '"use strict"; let [eval] = 1;',
            '!{ a(let) { "use strict"; } }',
            '(function a(eval) { "use strict"; })',
            'class a { get constructor() {} }',
            'switch(1) { case 2: !function(){ break; }; }',
            '(function package() {"use strict"; })()',
            '\\u0000',
            'class a {set constructor(b){}}',
            'if(1) c: b: function a(){}',
            'a\\u0000',
            '[...0] = 0;',
            'function* a() { (b = yield 1) => {} }',
            '"use strict"; arguments=>1',
            'function a() { "use strict"; var interface; }',
            //'"use strict"; [,,,eval,] = 1',
            'function a() {"use strict"; ({ b: function b(eval) { } }); }',
            'class a { constructor() { super(); } }',
            'class a { *constructor() {} }',
            'function a() {"use strict"; arguments--; }',
            '({ a(){ super(); } });',
            'for(const a = 1, b;;);',
            'for([0] of 0);',
            'function* a(){ ({ *b(c = yield){} }); }',
            '"use strict"; arguments *= 1',
            '"use strict"; !function arguments(){}',
            'for(let a of b) d: function c(){}',
            'switch(1) { case 2: function a(){ break; } }',
            '"use strict"; with();',
            'for({a: 0} in 0);',
            'do b: function a(){} while (1);',
            'function a() { "use strict"; var package; }',
            '[a] *= 0;',
            'let a, b, c, let;',
            '"use strict"; +yield',
            'function a() { "use strict"; implements = 1; }',
            'super.a',
            'function a([yield,...a]){ "use strict"; }',
            '"use strict"; var eval;',
            '({a([]){"use strict"}})',
            'while (true) { continue a; }',
            'for(;;) d: c: b: function a(){}',
            'break a;',
            '({ "__proto__": null, __proto__: null })',
            '"use strict"; function* eval(){}',
            '"use strict"; function a() { yield }',
            'function* a(){ !function*(b = yield){} }',
            '("\\u{110000}")',
            'a: if(1) continue a;',
            '"use strict"; ([yield] = a)',
            '({a: 0} = 0);',
            'for(({a: 0}) of 0);',
            '"use strict"; +package;',
            'b: while(1) continue a;',
            '(function () { "use strict"; with (a); }())',
            '"use strict"; (yield) => 1',
            'function a(b){ super() }',
            'class a { set b(eval){} };',
            'function a(b = super()){}',
            'function* a(){ function* b(c = yield* d){} }',
            'for(const a of b) d: function c(){}',
            '"use strict"; let yield = 1;',
            '!function(a){ super() }',
            '({ __proto__: null, __proto__: null })',
            'class a extends b { static set prototype(c) {} }',
            '"use strict"; ({ __proto__: 1, __proto__: 2 })',
            'a: while (true) { a: while (true) { } }',
            'for(const a = 1, let = 2;;);',
            '"use strict"; (arguments)=>1',
            '"use strict"; (a = yield) => {}',
            'class a extends b { static prototype(){} }',
            '"use strict"; (eval = 1) => 2',
            '"use strict"; if (1) function a(){}',
            'function* a(){ ({ *b([c = yield]){} }); }',
            'function a() {"use strict"; var eval = 1; }',
            'for(;;) b: function a(){}',
            'class a { get constructor(){} }',
            'class a {static prototype(){}}',
            'function a() { "use strict"; protected = 1; }',
            'if(1) b: function a(){}',
            '!{ a() { function* b(a = super.c()){} } };',
            'class a { b(eval){} };',
            '"use strict"; !function (eval){}',
            'function *a() { ({b = yield}) => {} }',
            '"use strict"; !{ set a(eval){} };',
            '!function* a(b = super()){}',
            'class a extends b { c() { function* d(c = super.e()){} } }',
            '"use strict"; function *a(){ var b = function yield(){}; }',
            'break',
            'function a(){ c: while(1) continue b; }',
            'function* a(){ (b = yield c) => 1; }',
            '/[a-z]/z',
            'for(const a = 1;;) c: function b(){}',
            'class a extends b { static get prototype(){} }',
            '"use strict"; var yield;',
            '"use strict"; function static() { }',
            '!function a(b){ super[1] }',
            'function* a(){ function* b({[yield]: c}){} }',
            '"use strict"; delete (((foo)))',
            'const let',
            'const let = 1',
            'let const',
            'let var',
            'with: icefapper',
            'let var',
            // Early ReferenceError!
            'Array() **= 10',

            // Note: The tests below are a dedication to Icefapper, so he can be happy! Regards, J.K. Thomas!

            'new.target = 42',
            'var foo = 1; new.target = foo = 42',
            'function eval() {"use strict"; }',
            'for (let let in a);',
            '"use strict"; function static() { }',
            '!function* (a){ super.b }',
            'class a extends b { c() { !function* (c = super.d()){} } }',
            '"use strict"; yield:;',
            '!{ a() { !function* (a = super.b()){} } };',
            'for(const a = 1;;) c: function b(){}',
            'a: continue a;',
            'continue;',
            'switch(1) { default: !function(){ break; }; }',
            'function a() { "use strict"; function b(arguments) {} }',
            '"use strict"; delete (a);',
            '(((...a)))',
            '"use strict"; arguments *= 1',
            '(function () { "use strict"; delete a; }())',
            '"use strict"; var arguments;',
            'function* a(){ ({b = yield}) => 1; }',
            'function* a(){ (b = yield c) => 1; }',
            'class a {static [static](){};}',
            'function* a(){ function* b(c = yield){} }',
            'function a(){ c: while(1) continue b; }',
            '"use strict"; function eval(){}',
            'for(const a;;);',
            'function a() {"use strict"; (function eval() { }()) }',
            `class a extends b { c() { function* d(c = super.e()){} } }`,
            '"use strict"; for (a in let) {}',
            'class a { *b(eval){} };',
            '!function* a(b = super()){}',
            '"use strict"; let [eval] = 1;',
            '!function* a(b) { super() }',
            'b: break a;',
            '!{ a(let) { "use strict"; } }',
            'function a() {"use strict"; --arguments; }',
            'for(let a;;) c: function b(){}',
            '--0',
            '"use strict"; ({a: arguments = 1} = 2)',
            'if(1) break;',
            'for(({a: 0}) in 0);',
            'class a {set constructor(b){}}',
            'function* a(b = super()){}',
            'for(let let;;);',
            'function a(){ break b; }',
            'while(1) { function a(){ continue; } }',
            'function a() { "use strict"; ({ b: function b(eval) { } }); }',
            '!{ set a(let) { "use strict"; } }',
            'with(1) b: function a(){}',
            '"use strict"; function* a(eval){}',
            'let let;',
            '!{ a() { !function* (){ super.b(); } } };',
            'class a { constructor() { super(); } }',
            'for(([0]) of 0);',
            'if(1) b: function a(){}',
            'for(const a = 1, b;;);',
            'class a extends b { static c() { super(); } }',
            'class a { set constructor(b) {} }',
            'function* a(){ ({ *b(c = yield){} }); }',
            '"use strict"; (class a { static constructor() { super() }})',
            'for(let a of b) d: function c(){}',
            'function* a(){ !function*({b = yield}){} }',
            'class a extends b { c() { function d(){ super.e(); } } }',
            'function a() { "use strict"; var package; }',
            'for([0] in 0);',
            '!{ *a(b) { super() } };',
            'function a() { "use strict"; package = 1; }',
            'function a(package) { "use strict"; }',
            'while (true) { continue a; }',
            '"use strict"; function a(...yield) {}',
            'break a;',
            '"use strict"; eval = 42;',

            // Async functions

            'async function a(k = super.prop) { }',
            '(async function(k = super.prop) {})',
            '(async function a(k = super.prop) {})',
            'async function a() { super.prop(); }',
            '(async function a() { super.prop(); })',
            '(async function a(k = super()) {})',
            '(async function a() { super(); })',
            '\'use strict\'; (async function eval() {})',
            '\'use strict\'; async function eval() {}',
            '(async function a(k = await 3) {})',
            'async function a(k = await 3) {}',

            // Class fields - Stage 3 proposal
            'var x = "string"; class C { static [x] = /*{ initializer }*/; }',
            'var x = "string"; class C { x = typeof /*{ initializer }*/; }',
            'var x = "string"; class C { static x = /*{ initializer }*/; }',
            'var x = "string"; class C { static x = /*{ initializer }*/; }',
            'var x = "string"; class C { static x = /*{ initializer }*/; }',
            'var x = "string"; class C { x = () => super(); }',
            'var x = "string"; class C { [x] = arguments; }',
            'var x = "string"; class C {  [x] = super(); }',
            'var x = "string"; class C { x = {} == super(); }',
            'var x = "string"; class C { x = arguments;}',
            'var x = "string"; class C { static [x] = arguments; }',
            'var x = "string"; class C { static [x] = super(); }',
            'var x = "string"; class C { static x = arguments; }',
            'var x = "string"; class C { static x = super(); }',
            'var x = "string"; class C { static "x" = arguments; }',
            'var x = "string"; class C { x = true ? {} : super();}',
            'var x = "string"; class C { x = typeof super(); }',
            'var x = "string"; class C { x = () => super(); }',
            'var x = "string"; class C { "x" = arguments; }',
            'var x = "string"; class C { x = false ? {} : super(); }',

            // Private fields  - Stage 3 proposal

            'var x = "string"; class C { #x = () => /*{ initializer }*/; }',
            'var x = "string"; class C {  #x = true ? {} : /*{ initializer }*/; }',
            'var x = "string"; class C { static #x = /*{ initializer }*/; }', // not implemented, so this will ofc. fail. / J.K Thomas.
            'var x = "string"; class C { #x = () => super(); }',
            'var x = "string"; class C {  #x = super(); }',
            'var x = "string"; class C {  #x = typeof super(); }',
        ];

        for (const arg of invalidSyntax) {
            it(`${arg}`, () => {
                t.throws(() => {
                    parse(`${arg}`, undefined, Context.OptionsNext);
                });
            });
        }
    });

    describe('Failure - Module code', () => {

        const invalidSyntax = [
            'import { x as eval } from "foo',
            'import { x as arguments } from  "foo";',
            'label: { label: 0; }',
            '{ import { x } from \'y\'; }',
            'while (false) { break icefapper; }',
            'while (false) { break foo; }',
            'var public;',
            'new.target;',
            `super;`,
        ];

        for (const arg of invalidSyntax) {
            it(`${arg}`, () => {
                t.throws(() => {
                    parse(`${arg}`, undefined, Context.Strict | Context.Module);
                });
            });
        }
    });
});