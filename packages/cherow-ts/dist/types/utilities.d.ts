import { IParser, Location, Errors, Token, ESTree, Context, Labels, ModifierState, ObjectState, CoverParenthesizedState, CoverCallState } from 'cherow';
export declare function validateBreakOrContinueLabel(parser: IParser, context: Context, label: string, isContinue: boolean): void;
export declare function addLabel(parser: IParser, label: string): void;
export declare function popLabel(parser: IParser, label: string): void;
export declare function hasLabel(parser: IParser, label: string): Labels;
export declare function finishNode<T extends ESTree.Node>(context: Context, parser: IParser, meta: Location, node: Partial<T>): T;
export declare function expect(parser: IParser, context: Context, token: Token, err?: Errors): boolean;
export declare function consume(parser: IParser, context: Context, token: Token): boolean;
export declare function nextToken(parser: IParser, context: Context): Token;
export declare const hasBit: (mask: number, flags: number) => boolean;
export declare function consumeSemicolon(parser: IParser, context: Context): void | boolean;
export declare function parseExpressionCoverGrammar<T>(parser: IParser, context: Context, callback: (parser: IParser, context: Context) => T): T;
export declare function restoreExpressionCoverGrammar<T>(parser: IParser, context: Context, callback: (parser: IParser, context: Context) => T): T;
export declare function swapContext<T>(parser: IParser, context: Context, state: ModifierState, callback: (parser: IParser, context: Context, state: ObjectState) => T, methodState?: ObjectState): T;
export declare function validateParams(parser: IParser, context: Context, params: string[]): void;
export declare const reinterpret: (parser: IParser, context: Context, node: any) => void;
export declare function lookahead<T>(parser: IParser, context: Context, callback: (parser: IParser, context: Context) => T): T;
export declare function isValidSimpleAssignmentTarget(node: ESTree.Node): boolean;
export declare function getLocation(parser: IParser): Location;
export declare function isValidIdentifier(context: Context, t: Token): boolean;
export declare function isLexical(parser: IParser, context: Context): boolean;
export declare function isEndOfCaseOrDefaultClauses(parser: IParser): boolean;
export declare function nextTokenIsLeftParenOrPeriod(parser: IParser, context: Context): boolean;
export declare function nextTokenisIdentifierOrParen(parser: IParser, context: Context): boolean | number;
export declare function nextTokenIsLeftParen(parser: IParser, context: Context): boolean;
export declare function nextTokenIsFuncKeywordOnSameLine(parser: IParser, context: Context): boolean;
export declare function isPropertyWithPrivateFieldKey(expr: any): boolean;
export declare function parseAndValidateIdentifier(parser: IParser, context: Context): void | ESTree.Identifier;
export declare function nameIsArgumentsOrEval(value: string): boolean;
export declare function setPendingError(parser: IParser): void;
export declare function isEqualTagNames(elementName: ESTree.JSXNamespacedName | ESTree.JSXIdentifier | ESTree.JSXMemberExpression): string;
export declare function isInstanceField(parser: IParser): boolean;
export declare function validateUpdateExpression(parser: IParser, context: Context, expr: ESTree.Expression, prefix: string): void;
export declare function setPendingExpressionError(parser: IParser, type: Errors): void;
export declare function validateCoverParenthesizedExpression(parser: IParser, state: CoverParenthesizedState): CoverParenthesizedState;
export declare function validateAsyncArgumentList(parser: IParser, context: Context, state: CoverCallState): CoverCallState;
export declare function keywordTypeFromName(value: string): string | undefined;
